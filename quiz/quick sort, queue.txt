1. Quick Sort의 기본 아이디어는 뭔가? Merge Sort와는 어떻게 다른가? 설명하라.

 퀵 정렬과 병합 정렬은 모두 평균적으로 O(nlogn)의 시간 복잡도를 갖고 있는 정렬 알고리즘입니다. 이러한 시간 복잡도가 가능한 것은 두 알고리즘 모두 재귀적으로 범위를 분할하면서 정렬하기 때문입니다. Quick Sort와 Merge Sort의 가장 큰 차이점은 정렬 시 피봇(pivot)을 사용여부입니다.

 퀵 정렬은 피봇(pivot)이라는 값을 하나 정하고 피봇값을 기준으로 작은 수는 왼쪽으로 큰 수는 우측으로 자리를 교환해가며 수를 정렬합니다. 피봇값은 이론상 범위내 어떠한 수가 되도 상관없는 것으로 되어 있으나 배열의 양끝값 혹은 중간값 등을 고정하여 연산하는 것이 구현하기에도 편리하고 속도도 더 빠르다고 합니다. 이때 배열 좌측 끝과 우측 끝에는 포인터를 하나씩 두고 좌측의 포인터는 우측으로 우측의 포인터는 좌측으로 이동시킵니다. 좌측 포인터는 피봇값보다 작은 값을 만나면 멈추고 우측 포인터는 피봇값보다 큰값을 만나면 포인터를 멈추고 서로 자리를 바꿔줍니다. 이런 식으로 배열 안의 모든 수를 피봇 기준으로 정렬하다보면 포인터들이 서로 만나는 순간이 옵니다. 그 자리가 피봇 값이 위치할 자리입니다. 피봇과 해당 자리의 숫자를 교환해주고 현재 포인터가 멈춘 자리 기준으로 배열을 좌측과 우측으로 분할(partition)하여 앞에 진행한 것과 같은 방식으로 정렬을 진행합니다. 배열을 분할하고 분할해서 더이상 분할할 수 없을 때까지 반복적으로 정렬하면 배열이 모두 정렬되게 됩니다.

 Merge Sort 보다 Quick Sort가 빠른 이유는 Merge Sort는 병합 과정의 왼쪽과 오른쪽 데이터를 합치는 동작에서 정렬을 한 번 더 진행해야 하기 때문입니다. 또한, 해당 정렬을 진행하는 과정에서 임시 배열을 하나 생성해야 합니다. 하지만 Quick Sort의 경우에는 원 배열을 부분배열로 분할하기는 하지만 병합이라는 과정이 없기 때문에 임시 배열을 만들거나 병합 시에 데이터를 재정렬할 필요가 없습니다.


2. 지금까지 본 Data structure들과 Queue는 어떤 면이 비슷하고 어떤 면이 다른가? 그래서 어떤 경우에 사용 하는가? 설명해 보라.

 큐(queue)는 컴퓨터의 기본적인 자료 구조의 한가지로, 먼저 집어 넣은 데이터가 먼저 나오는 FIFO (First In First Out)구조로 저장하는 형식을 말합니다. 영어 단어 queue는 표를 사러 일렬로 늘어선 사람들로 이루어진 줄을 말하기도 하며, 먼저 줄을 선 사람이 먼저 나갈 수 있는 상황을 연상하면 됩니다. 나중에 집어 넣은 데이터가 먼저 나오는 스택과는 반대되는 개념입니다.

 스택(stack)은 제한적으로 접근할 수 있는 나열 구조이다. 그 접근 방법은 언제나 목록의 끝에서만 일어난다. 끝먼저내기 목록(Pushdown list)이라고도 합니다. 스택은 한 쪽 끝에서만 자료를 넣거나 뺄 수 있는 선형 구조(LIFO - Last In First Out)으로 되어 있다. 자료를 넣는 것을 '밀어넣는다' 하여 푸쉬(push)라고 하고 반대로 넣어둔 자료를 꺼내는 것을 팝(pop)이라고 하는데, 이때 꺼내지는 자료는 가장 최근에 푸쉬한 자료부터 나오게 됩니다. 이처럼 나중에 넣은 값이 먼저 나오는 것을 LIFO 구조라고 합니다.

 큐의 데이터 구조면에 있어서 LIFO와 FIFO라는 차이점이 드러나는 것은 스택입니다. 또 리스트와 비교해봤을 때, 리스트는 읽기, 삽입, 삭제를 리스트의 어느 곳에서나 행합니다. 큐는 삽입은 리스트의 한쪽에서 하고, 삭제는 삽입의 반대쪽에서 행합니다.

 큐(queue)는 프린터의 출력 처리나 윈도 시스템의 메시지 처리기, 프로세스 관리 등 데이터가 입력된 시간 순서대로 처리해야 할 필요가 있는 상황에 이용됩니다. 컴퓨터 안에 여러 개의 프로세스가 수행 중인데, 새로운 프로세스가 수행되어야 하는 경우 기존에 수행되던 프로세스 중에서 가장 먼저 메모리에 올라온 프로세스가 아웃되고(실행), 새로운 프로세스를 메모리에 올리게 됩니다. 이 경우에 운영체제는 현재 수행 중인 프로세소를 큐의 형태로 관리합니다.




