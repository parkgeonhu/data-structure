1. Time complexity의 개념을 가지고 우리가 2장과 3장의 두 구현을 비교 분석 해 보고자 한다. add(anEntry), remove(), remove(anEntry), 그리고 contains(anEntry)만 비교 해 보라. 어떤 것이 어떻게 유리한가? 설명하라.

add(anEntry) // LinkedBag 같은 경우, Node를 하나 생성하여 LinkedBag의 firstnode로 설정하기 때문에 바로 저장공간에 접근하는 ArrayBag과 비교해서 조금 느릴 수 있습니다.
remove() // 가장 최근에 추가된 요소를 제거하기 때문에 시간복잡도면에서 차이점이 없습니다.
remove(anEntry) // LinkedBag 같은 경우 getReferenceTo에서 O(n), ArrayBag 같은 경우 getIndexOf에서 O(n)이다.  자료의 삭제 매커니즘은 동일하기에 시간복잡도면에서 차이점이 없습니다.
contains(anEntry) // LinkedBag 같은 경우 getReferenceTo에서 O(n), ArrayBag 같은 경우 getIndexOf에서 O(n)이다. 저장공간의 처음부터 시작해 끝까지 찾아내는 매커니즘이기에 시간복잡도면에서 차이점이 없습니다.

2. 교과서 1장 - 3장에서는 ADT bag를 구현 했다. 이번에 구현하고자 하는 ADT Stack과는 어떤 것이 같고 어떤 것이 다른가? 비교해 보라.
 

Bag란 원소들을 단순히 모아놓은 것을 말합니다. 따라서 원소들 간에 아무 순서도 없고, 중복된 원소가 있을 수 있습니다. list와 array의 경우, 순서가 있고, 중복이 가능합니다. set와 같은 경우, 집합이므로 순서는 없지만 중복이 불가능합니다. 자료구조의 기본 Interface로써 Bag를 꼽을 수 있기 때문에 최상단 추상화를 거친 것이 BagInterface입니다. BagInterface라는 것을 만들고 그것을 상속시켜 ArrayBag과 LinkedBag을 만들 수 있습니다.

ArrayBag
배열은 데이터를 논리적 순서에 따라 순차적으로 데이터를 입력하며, 물리적 주소 또한 순차적입니다. 그리고 인덱스를 가지고 있어서 원하는 데이터를 한번에 접근이 가능하기 데이터 접근 속도가 매우 빠릅니다. 그러나 배열은 데이터의 삽입/삭제에는 취약합니다. 배열 특성상 데이터 삽입/삭제가 이루어지면 삽입/삭제가 이루어진 위치의 다음부터 모든 데이터의 위치를 변경해야 하기 때문입니다. 만약에 배열 데이터의 수가 10000개라고 하고 삽입/삭제가 빈번하게 일어난다고 가정을 하고 생각을 하면 프로그램은 데이터 삽입/삭제 때마다 데이터의 위치를 바꾸는데만 많은 리소스를 사용할 것입니다.

LinkedBag
연결리스트는 데이터를 논리적 순서에 따라 데이터를 입력합니다. 하지만 물리적 주소는 순차적이지 않습니다. 인덱스를 가지고 있는 배열과는 달리 연결리스트는 인덱스 대신 현재 위치의 이전 및 다음 위치를 기억하고 있습니다. 때문에 한번에 데이터 접근이 가능하지 않고 연결되어 있는 링크를 따라가야만 접근이 가능하고, 배열에 비해 속도가 떨어집니다. 하지만 데이터 삽입/삭제는 논리적 주소만 바꿔주면 되기 때문에 데이터 삽입/삭제는 용이합니다.

Stack, 스택
데이터를 집어넣을 수 있는 선형(Linear) 자료형입니다. 나중에 집어넣은 데이터가 먼저 나오는 구조, LIFO (Last In First Out) 입니다. 사용되는 Property(특성, 속성) 또는 메소드는 push(넣기), pop(빼기), peek(가장 마지막 집어넣은 데이터 확인)입니다. peek 가 있는 이유를 생각해봤을 때, 브라우저에서 이전 페이지, 작업을 확인하는 경우에 필요합니다. pop을 할 경우 가장 마지막에 저장된 데이터가 빠져나갑니다. 데이터를 순서대로 입력을 받습니다. 이번 ADT Stack을 구현할 때는 링크드리스트, array로 구현하는 방법이 있어 공통점과 차이점은 위의 특징들과 비교한 것이 차이점입니다.

