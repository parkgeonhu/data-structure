1. 교과서 4장에서는 무슨 문제가 있고, 어떻게 하겠다는 이야기 인가? 전체적인 아이디어가 뭔가? 설명하라.

4장은 프로그램 구조상 복잡도를 알아보는 장입니다. 어떻게 하면 같은 기능을 하지만 시간이 '적게' 걸리고, 공간을 '적게' 차지하는 최적의 알고리즘을 찾을 수 있을까 생각할 수 있는 장입니다. 그래서 알고리즘의 시간복잡도와 공간복잡도를 계산하는 방법을 제시합니다. 4장에는 같은 기능을 하지만, 시간과 공간의 최소로 하는 알고리즘을 찾기 위한 문제들이 있습니다. 각 문제의 알고리즘들을 Big-O 표기를 하며, 어떤 알고리즘이 제일 나은지 최고차항의 비교를 합니다. 

Complexity(복잡도)
Compuer Science에서 복잡도(Complexity)는 대상 프로그램 혹은 알고리즘의 성능을 평가 할 수 있는 주요한 지표중의 하나로 Computer Compexity Theory 입니다다. 복잡도는 시간 복잡도(Time Complexity)와 공간 복잡도(Space Complexity)가 있으며 알고리즘마다 조금씩 다르지만 대체적으로 시간복잡도와 공간 복잡도는 어느정도 Trade off 관계를 가집니다.

복잡도를 표현하는 방법
복잡도는 거의 대부분 데이터 개수에 따른 수행시간, 혹은 필요공간을 점근 표기법으로 표현합니다. Big O를 이용하여 데이터의 복잡도를 계산할때에는 데이터 n에 대한 최고차항의 수를 보통 표기합니다. 시간 복잡도는 알고리즘의 명령어 수행 횟수를 이용하여 계산합니다. 즉, 명령어를 수행하는 횟수가 많을수록 알고리즘을 수행하는데 걸리는 시간은 증가하므로 이를 이용합니다.



2. 교과서 177쪽 exercise 10

counter는 n값입니다. for문에서 세번째 식을 보면 counter=/2를 수행하고 있습니다. 따라서 for문을 한번 수행할 때마다 counter가 절반으로 줄어들기 때문에 시간복잡도는 O(log2n) // (log의 밑은 2) 입니다.
