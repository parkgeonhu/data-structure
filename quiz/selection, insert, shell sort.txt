1. selection sort와 insertion sort는 각각 어떻게 하는 것이고 어떤 경우에 유리한가? 설명하라
 선택정렬은 최솟값을 찾아 앞쪽으로 이동하기를 배열 크기만큼 반복하는 알고리즘입니다. 삽입 정렬은 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘입니다.
 선택정렬은 정렬되어 있지 않은 수를 전부 확인해 가장 작은 수를 찾아야합니다. 정렬이 전부 되어 있어도 모든 수를 비교합니다. 삽입 정렬은 정확한 위치에 들어가는 것을 결정하기 위해 정렬 중인 array를 확인 해야합니다. 필요한 값만 읽고 정렬된 리스트에서 비교합니다.
 n개의 element가 있다고 가정할 때, selection은 n번만 쓰면 됩니다. 뒤에서부터 쓰기 때문에 array의 key들이 이동할 필요가 없지만, insertion은 key들이 전부 이동할 수도 있기 때문에 writing이 더 많이 일어납니다.
 만약 전부 정렬된 리스트를 비교한다면 insertion sort의 시간복잡도는 O(n)이지만, selection sort는 여전히 O(n^2)입니다. 



2.shell sort의 기본 아이디어는 뭔가? 즉, 어떻게 performance를 향상시키겠다는 것인지 설명해 보라 
셸 정렬(shell sort) 알고리즘이란?
‘Donald L. Shell’이라는 사람이 제안한 방법으로, 삽입정렬을 보완한 알고리즘입니다. 삽입 정렬이 어느 정도 정렬된 배열에 대해서는 대단히 빠른 것에 착안했습니다. 삽입 정렬의 최대 문제점은 요소들이 삽입될 때, 이웃한 위치로만 이동한다는 것입니다. 즉, 만약 삽입되어야 할 위치가 현재 위치에서 상당히 멀리 떨어진 곳이라면 많은 이동을 해야만 제자리로 갈 수 있습니다. 

삽입정렬의 performance를 향상시킬 수 있는 방법
삽입 정렬과 다르게 셸 정렬은 전체의 리스트를 한 번에 정렬하지 않습니다. 과정은 다음과 같습니다.
첫 번째로, 정렬해야 할 리스트를 일정한 기준에 따라 분류합니다. 두 번째로, 연속적이지 않은 여러 개의 부분 리스트를 생성합니다. 세 번째로, 각 부분 리스트를 삽입 정렬을 이용하여 정렬합니다. 네 번째로, 모든 부분 리스트가 정렬되면 다시 전체 리스트를 더 적은 개수의 부분 리스트로 만든 후에 알고리즘을 반복합니다. 위의 과정을 부분 리스트의 개수가 1이 될 때까지 반복합니다.